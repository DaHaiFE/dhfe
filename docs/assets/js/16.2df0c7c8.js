(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{342:function(t,n,s){"use strict";s.r(n);var e=s(1),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"content"},[s("p",[t._v("ES6 关键字class、constructor、extends、static简介")]),s("p",[t._v("先来看下传统ES5的写法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// ES5写法 \nfunction StdInfo() {\n\t\tthis.name = "cat";\n\t\tthis.age = 30;\n}\n\nStdInfo.prototype.getNames = function () {\n    console.log("name：" + this.name);\n}\n//得到一个学员信息的对象\nvar p = new StdInfo()\np.getNames()\n')])]),s("h2",{attrs:{id:"一、class-使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、class-使用","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、class 使用")]),s("p",[t._v("实质:\n   在类的实例中调用方法，其实就是调用原型上的方法。P = new Parent() P.constructor === Parent.prototype.constructor")]),s("p",[t._v("注：\n1.class定义类不存在变量提升，只能先定义类后使用，跟函数声明有区别的。"),s("br"),t._v("\n2. 定义在类中的方法不需要添加function。"),s("br"),t._v("\n3.函数的定义方式有函数声明和函数表达式两种，类的定义方式也有两种，分别是：类声明和类表达式。\n4、表达式申明时候，class关键字之后的类名可有可无，如果存在，则只能在类内部使用"),s("br"),t._v("\n5、方法之间不需要加逗号，否则会报错"),s("br"),t._v("\n6、类必须使用new调用，否则会报错 (ES5 中可以直接调用)"),s("br"),t._v("\n示例代码：\n动态添加方法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Object.assign(Parent.prototype, {\n\t  getName() {\n\t\t  console.log('覆盖原来定义的')\n\t  }\n})\n")])]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 表达式：\n  const People = class StdInfo {\n\t\t    constructor(){\n\t\t\t\tconsole.log(StdInfo);  \n\t\t\t   // 这里可以打印出值，是一个函数\n\t\t\t}\n\t\t\tgetName () { // 不需要添加function\n\n\t\t    }\n}\n// 声明：\nclass StdInfo { }\n")])]),s("h3",{attrs:{id:"二、constructor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、constructor","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、constructor")]),s("p",[t._v("意义：类初始化时候执行的函数"),s("br"),t._v("\n作用：初始化属性, 传入所需要的参数"),s("br"),t._v("\n返回值：自动返回实例对象"),s("br"),t._v("\n注意点：1、可以省略constructor ，一个类中只能有一个constructor函数，定义多个会报错"),s("br"),t._v("\n2、继承时候super() 需要写在constructor里面调用，然后才能使用this\n示例代码：\\")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Parent {\n\t constructor(name, age) {\n\t\tsuper(name, age) //初始化属性\n\t\tthis.name = name // super 之前会报错， 应该写在super 之后\n\t}\n}\n")])]),s("h3",{attrs:{id:"三、继承-extends"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、继承-extends","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、继承 extends")]),s("p",[t._v("ES5继承原理： 实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Par继承ent.apply(this) ）。"),s("br"),t._v("\n    ES6继承原理：质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\\")]),s("p",[t._v("示例代码：")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Parent {\n\t\tconstructor(name, age) {\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.age = age;\n\t\t}\n\t\tgetName() {\n\t\t\t\tconsole.log(this.name)\n\t\t}\n}\nclass Child extends Parent {\n\t\tconstructor(name, age) {\n\t\t\t\tsuper(name, age) //代表父类的构造函数\n\t\t\t\tthis.name = name // super 之前会报错， 应该写在super 之后\n\t\t}\n}\n")])]),s("h3",{attrs:{id:"四、static-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、static-的使用","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、static 的使用")]),s("p",[t._v('解释：类其实就是实例的原型， 所有在类中定义的方法， 都会被实例继承，在new 一个实例后就可以直接使用类中的方法。如果在一个方法前， 加上static关键字,就表示这个方法不会被实例继承， 而是直接通过类来调用，及 "类名"+ \'.\' + "方法名" ， 这就称为“ 静态方法”。\n    作用： 写工具 函数')]),s("p",[t._v("使用方式：\n    1、类中通过类名 直接调用 不能在实例后调用实例的方法。")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class StuInfo {\n\t\tstatic staticMethodsParent() {\n\t\t  console.log('static 使用1 from 父类');\n\t\t}\n}\nStuInfo.staticMethodsParent()\n")])]),s("p",[t._v("2、子类可以调用父类的静态方法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Parent {\n\t\tstatic staticMethodsParent() {\n\t\t  console.log('static 使用1 from 父类');\n\t\t}\n}\nclass Child extends Parent {\n        constructor() {\n            super() // 不管是否有这个super，子类都可以获取到父类的静态方法\n        }\n\t\tstatic staticMethodsChild() {\n\t\t\tconsole.log('static 使用2 from 子类');\n\t\t}\n}\n\nChild.staticMethodsChild() // static 使用2 from 子类'\nChild.staticMethodsParent() // static 使用1 from 父类\n")])]),s("p",[t._v("3、 通过关键字this 使用 static 定义的方法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class StuInfo{\n\t\tconstructor () {\n\t\t\t\tthis.constructor.getStaticMethodsName()\n\t\t}\n\t\tstatic staticMethodsParent() {\n\t\t\t\tconsole.log('static 使用3 from 父类');\n\t\t}\n}\nStuInfo.staticMethodsParent()\n")])]),s("p",[t._v("4、 通过this 使用static 的第二种情况 ，在一个静态方法中 使用另一个静态方法,直接this.静态方法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class StuInfo {\n\t\t\tstatic staticMethodsParent1() {\n\t\t\t\treturn \"第一个静态方法返回值\"\n\t\t\t}\n\t\t\tstatic staticMethodsParent2() {\n\t\t\t   console.log('第二个静态方法执行得到的结果：' + this.staticMethodsParent1())\n\t\t\t}\n}\nStuInfo.staticMethodsParent2()\n")])]),s("p",[t._v("5、通过super 调用父级的 静态方法")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Parent {\n\t\t\tstatic staticMethodsParent() {\n\t\t\t\tconsole.log('父级的 static ');\n\t\t\t}\n\t}\n\n\tclass Child extends Parent {\n\t\t\tconstructor () {\n\t\t\t\tsuper()\n\t\t\t}\n\t\t\tstatic staticMethodsChild() {\n\t\t\t\tconsole.log( super.staticMethodsParent())\n\t\t\t}\n\t}\t\n   Child.staticMethodsChild()\n")])])])}],!1,null,null,null);a.options.__file="es6-extends-static.md";n.default=a.exports}}]);