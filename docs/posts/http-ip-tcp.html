<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>全面了解TCP/IP到HTTP · 大海前端团队 · 一群有趣有爱的人儿一起做有意义的事儿</title>
    <meta name="description" content="本文简单介绍了TCP/IP与HTTP，给前端开发人员了解，如有兴趣可参考专业书籍进行深入探索，有兴趣的还可以看看TCP服务器设计以及T/TCP还有HTTPS，同时欢迎各位指正、交流！">
    <link rel="shortcut icon" href="/favicon.ico">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3F51B5">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="content-type" content="no-cache, must-revalidate">
  <meta http-equiv="expires" content="Wed, 26 Feb 1997 08:21:57 GMT">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/192.png">
  <meta name="msapplication-TileImage" content="/icons/192.png">
  <meta name="msapplication-TileColor" content="#3F51B5">
    
    <link rel="preload" href="/assets/css/styles.7e3bbdcf.css" as="style"><link rel="preload" href="/assets/js/app.7e3bbdcf.js" as="script"><link rel="preload" href="/assets/css/styles.7e3bbdcf.css" as="style"><link rel="preload" href="/assets/js/19.a350b227.js" as="script"><link rel="prefetch" href="/assets/js/1.b7c064a0.js"><link rel="prefetch" href="/assets/js/10.c57460b4.js"><link rel="prefetch" href="/assets/js/11.ef43cd88.js"><link rel="prefetch" href="/assets/js/12.9ac7e3d6.js"><link rel="prefetch" href="/assets/js/13.9e579e95.js"><link rel="prefetch" href="/assets/js/14.81038537.js"><link rel="prefetch" href="/assets/js/15.20f7fea5.js"><link rel="prefetch" href="/assets/js/16.cccdc5d6.js"><link rel="prefetch" href="/assets/js/17.2f55acf1.js"><link rel="prefetch" href="/assets/js/18.04e66a8c.js"><link rel="prefetch" href="/assets/js/2.30690309.js"><link rel="prefetch" href="/assets/js/20.382325d7.js"><link rel="prefetch" href="/assets/js/21.42d01bdd.js"><link rel="prefetch" href="/assets/js/22.bb8a390e.js"><link rel="prefetch" href="/assets/js/23.63a55c5d.js"><link rel="prefetch" href="/assets/js/3.de4e9704.js"><link rel="prefetch" href="/assets/js/4.eae0a007.js"><link rel="prefetch" href="/assets/js/5.95a53548.js"><link rel="prefetch" href="/assets/js/6.7b8bfb0a.js"><link rel="prefetch" href="/assets/js/7.703c38fc.js"><link rel="prefetch" href="/assets/js/8.966beaed.js"><link rel="prefetch" href="/assets/js/9.b035af40.js">
    <link rel="stylesheet" href="/assets/css/styles.7e3bbdcf.css"><link rel="stylesheet" href="/assets/css/styles.7e3bbdcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="application theme--light"><div class="application--wrap"><div role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" class="v-progress-linear blog-progress" style="height:3px;display:none;"><div class="v-progress-linear__background accent" style="height:3px;opacity:0.4;width:100%;"></div><div class="v-progress-linear__bar"><!----><div class="v-progress-linear__bar__determinate accent" style="width:0%;"></div></div></div><aside class="v-navigation-drawer v-navigation-drawer--close v-navigation-drawer--fixed v-navigation-drawer--is-mobile theme--light" style="height:100%;margin-top:0px;max-height:calc(100% - 0px);transform:translateX(-240px);width:240px;"><div><div class="aside-brand-wrap" style="display:;"><div class="aside-brand"><a href="/" class="aside-avatar elevation-2 router-link-active"><img src="/face.jpg" alt="avatar"></a><hgroup class="mt-3 variant-hide"><div class="subheading white--text">大海前端团队-DHFE</div><a href="javacript:void(0)" title="有爱有趣" class="aside-mail primary--text text--lighten-5">有爱有趣</a></hgroup></div></div><hr class="v-divider theme--dark"><div role="list" class="v-list nav-list theme--light"><div role="listitem" class="secondary--text"><a href="/blog" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-tag"></i></div></div><div class="v-list__tile__content">Blog</div></a></div><div role="listitem" class="secondary--text"><a href="https://github.com/DahaiFE/dhfe" target="_blank" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fab fa-github"></i></div></div><div class="v-list__tile__content">Github</div></a></div><div role="listitem" class="secondary--text"><a href="/about" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-user-secret"></i></div></div><div class="v-list__tile__content">About</div></a></div><div role="listitem" class="secondary--text"><a href="/join" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-users"></i></div></div><div class="v-list__tile__content">Join</div></a></div></div></div><div class="v-navigation-drawer__border"></div></aside><main class="v-content" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-content__wrap"><div class="container blog-container grid-list-xl align-center"><div class="layout row wrap"><div class="flex mb-3 xs12"><article class="mb-lay v-card v-sheet theme--light elevation-2 elevation-16 post-card"><div class="v-card__title"><div class="flex xs12"><h2 class="display-1 mb-3">全面了解TCP/IP到HTTP</h2><div class="post-meta"><time datetime="2018-01-18T00:00:00.000Z" class="secondary--text post-time">2018年01月18日</time></div></div></div><div class="v-card__text pt-0 pb-0"><div class="flex xs12"><div class="content custom"><p>本文简单介绍了TCP/IP与HTTP，给前端开发人员了解，如有兴趣可参考专业书籍进行深入探索，有兴趣的还可以看看TCP服务器设计以及T/TCP还有HTTPS，同时欢迎各位指正、交流！</p><h3 id="一、osi参考模型"><a href="#一、osi参考模型" aria-hidden="true" class="header-anchor">#</a> 一、OSI参考模型</h3><blockquote><p>OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即ISO开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/10057179-a7c8f44d0763c90c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI模型1.png"></p><h3 id="二、tcp-ip四层协议系统"><a href="#二、tcp-ip四层协议系统" aria-hidden="true" class="header-anchor">#</a> 二、TCP/IP四层协议系统</h3><p>TCP/IP是一组不同层次上的多个协议的组合,通常被认为是一个四层协议系统。</p><ul><li>链路层，有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</li><li>网络层，有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP网际协议，ICMP互联网控制报文协议，以及IGMP组管理协议。</li><li>传输层，主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分
成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于传输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。这两种运输层协议分别在不同的应用程序中有不同的用途。</li><li>应用层负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现都会提供这些通用的应用程序：Telnet远程登录、FTP文件传输协议、SMTP简单邮件传送协议、SNMP简单网络管理协议。</li></ul><p>我们需要知道<em>TCP在不可靠的IP层上提供了一个可靠的运输层</em>，这样就不会在后面介绍IP协议的时候出现模糊，TCP采用了超时重传、发送和接收端到端的确认分组等机制。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-3b3c2368aaf5c82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCPIP四层.png"></p><h4 id="链路层"><a href="#链路层" aria-hidden="true" class="header-anchor">#</a> 链路层</h4><blockquote><p>链路层协议是Internet协议族中的最底层协议。在TCP/IP协议中，链路层主要有三个作用：（1）发送和接收IP数据报（2）发送APR请求和接收APR应答（3）发送RAPR请求和接收RAPR应答。在这里我们还需要知道以太网和802封装，以太网是指数字设备公司在1 9 8 2年联合公布的一个标准也是当今 T C P / I P采用的主要的局域网技术，802标准指的是IEEE（电子电气工程师协会）802委员会公布的一个稍有不同的标准集，802.3标准定义了帧和以太网的帧都有最小长度要求。</p></blockquote><ol><li>串行线路IP（SLIP）</li></ol><p>这是一种在串行线路上对IP数据报进行封装的一种形式，这个协议定义了固定的数据帧格式，规定IP数据报以一个称作END(0XC0)的特殊字符结束，为了防止线路噪声也被当成数据报内容，所以一般在数据报开始的时候也传入一个END字符；如果IP报文中的某个字符为END那么需要连续传输两个字符0xdb和0xdc来取代它，0xdb这个字符被称作SLIP的ESC字符。SLIP是一种简单的封装，它有一些缺陷：每一端必须知道对方的IP地址；一条串行线路如果使用了SLIP协议那么它将不能同时使用其他协议；而且SLIP没用在数据帧加上检验，所以说报文因受到影响而发生错误只能通过上层协议来发现。在目前SLIP是一种广泛使用的协议。由于串行线路的速率较低，并且SLIP在性能上也有一些缺陷，后期提出了一个CSLIP（压缩SLIP）新协议<a href="https://tools.ietf.org/html/rfc1144" target="_blank" rel="noopener noreferrer">参考RFC 1144</a>。</p><ol start="2"><li>点对点协议PPP</li></ol><p>点对点协议修改了SLIP中的缺陷，PPP既支持数据为 8位和无奇偶检验的异步模式
（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接；它允许通信双方进行协商，以确定不同的选项；允许双方商定是否对报文首部进行压缩。PPP协议要比SLIP协议有更多的优点，但是目前SLIP的用户仍然要多于PPP用户。</p><ol start="3"><li>环回接口</li></ol><p>环回接口用来允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信，A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入</p><ol start="4"><li>最大传输单元MTU</li></ol><p>我们知道以太网对数据帧的长度都有一个限制，链路层的这个特性被称为MTU，不同类型的网络都有一个上限，如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU。当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU，它取决于所选择的路由。</p><hr><h4 id="ip网际协议"><a href="#ip网际协议" aria-hidden="true" class="header-anchor">#</a> IP网际协议</h4><blockquote><p>IP是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。IP协议是TCP/IP协议族中最核心的协议。它是一个不可靠的、无连接的协议，TCP、UDP、ICMP以及ICGP都以IP数据报格式传输。不可靠的意思是IP仅仅提供最好的传输服务，不能保证数据报能成功到达目的地。无连接的意思是并不维护任何关于后续数据报的状态信息，每个数据报的处理都是相互独立的，可以不按发送顺序接收。这里我主要解释下IP首部各个字段，这也是一个前端需要了解的。</p></blockquote><ol><li>IP首部</li></ol><p>普通的IP首部长为20个字节（不含选项字段）</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-86fa951249aeafcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP协议1-1.png"></p><p>首部最高位在左边，记为0bit；最低位在右边，记为31bit。4个字节的32bit值的传输：首先是 0～7 bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作网络字节序，TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，以其他形式存储二进制整数的机器，必须在传输数据之前把首部转换成网络字节序。目前的协议版本号是4，这也就是我们常说的IPv4。IP数据报的长度称为<strong>总长度字段</strong>，利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度，一般主机主机要求不能接收超过576字节的数据报，这个限制不会影响到TCP，因为它会把用户数据分片，<strong>总长度字段</strong>是IP首部中必要的内容。<strong>标识字段</strong>唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。<strong>TTL生存时间字段</strong>设置了数据报可以经过的最多路由器数，初始值由源主机设定，每经过一个处理的路由器它就会减1，<em>该字段为0时数据报就被丢弃</em>。每一份IP数据报都包含源IP地址和目标IP地址。<strong>最后一个字段</strong>是任选项，是数据报中的一个可选信息而且长度可变，包括时间戳、宽松的源站选路等等。</p><ol start="2"><li>子网寻址和子网掩码</li></ol><p>目前所有的主机都支持子网编址，不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。除了IP地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号。这是在引导过程中通过子网掩码来确定的，这个掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号，给定IP地址和子网掩码以后，主机就可以确定IP数据报的目标地址，根据子网掩码可知道子网号与主机号之间的分界线。</p><h4 id="icmp控制报文协议"><a href="#icmp控制报文协议" aria-hidden="true" class="header-anchor">#</a> ICMP控制报文协议</h4><p>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。
ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。所有报文的前4个字节都是一样的，但是剩下的其他字节则互不相同，ICMP报文格式(见图ICMP报文3-1)。不的类型由报文中的类型字段和代码字段来共同决定。ICMP报文需要区分时候查询报文还是差错报文，而且有时差错报文需要做特殊处理。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-13e032fee7f63318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ICMP报文3-1.png"></p><h4 id="igmp组管理协议"><a href="#igmp组管理协议" aria-hidden="true" class="header-anchor">#</a> IGMP组管理协议</h4><p>IGMP组管理协议主要用于用于支持主机和路由器进行多播。IGMP也被当作IP层的一部分，IGMP报文通过IP数据报进行传输，有固定的报文长度，没有可选数据(图IGMP报文字段)。多播路由器使IGMP报文来记录与该路由器相连网络中组成员的变化情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-7cfc3ea62ae09675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IGMP报文字段.png"></p><hr><h4 id="udp用户数据报协议"><a href="#udp用户数据报协议" aria-hidden="true" class="header-anchor">#</a> UDP用户数据报协议</h4><blockquote><p>UDP是一个简单的面向数据报的传输层协议，进程的每个输出操作都正好产生一个 UDP数据报，并组装成一份待发送的IP数据报。UDP不提供可靠性，它把应用程序传给 IP层的数据发送出去，但是并不保证它们能到达目的地。</p></blockquote><ol><li>UDP首部</li></ol><p>端口号表示发送进程和接收进程，UDP长度字段指的是UDP首部和UDP数据的字节长度，UDP检验和(可选的)覆盖UDP首部和UDP数据，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-e89c32cebb1f2803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP首部1-1.png"></p><ol start="2"><li>UDP数据报最大长度</li></ol><p>去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为
65507字节。但是，大多数实现所提供的长度比这个最大值小。</p><h4 id="tcp传输控制协议"><a href="#tcp传输控制协议" aria-hidden="true" class="header-anchor">#</a> TCP传输控制协议</h4><blockquote><p>TCP提供一种面向连接的、可靠的字节流服务。面向连接意味着两个应用在彼此交换数据之前必须先建立一个TCP连接。TCP为应用层提供全双工服务。</p></blockquote><p>TCP通过下列方式来提供可靠性：应用数据被分割成TCP认为最适合发送的数据块；当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段；当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认会有一点延迟；TCP将保持它首部和数据的检验和；TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；TCP还能提供流量控制。</p><ol><li>TCP首部</li></ol><p>TCP数据被封装在一个IP数据报中(如图TCP1-1所示)</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-55c681b9c84958cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP1-1.png"></p><p>TCP首部(如图TCP1-2所示)，如果不计任选字段通常是20个字节。每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。32位序号用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。在TCP首部中有6个标志比特：<strong>URG(紧急指针有效) ACK(确认序号有效) PSH(接收方应该尽快将这个报文段交给应用层) RST(重建连接) SYN(同步序号用来发起一个连接) FIN(发端完成发送任务)</strong>。</p><p>检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。只有当URG标志置1时紧急指针才有效。</p><p>最常见的可选字段是最长报文大小，每个连接方通常都在通信的第一个报文段中指明这个选项。TCP报文段中的数据部分是可选的，一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-fe018275906c5527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP1-2.png"></p><ol start="2"><li>TCP的三次握手与四次挥手</li></ol><p>当建立一个TCP连接的时候，通过三个报文段来完成连接的建立，这个过程称为三次握手。(见图TCP2-1)</p><p>(1)请求端（通常称为客户端）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号。</p><p>(2)服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。</p><p>(3)客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-42cc3fd514633d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP2-1.png"></p><p>由于TCP的半关闭，终止一个连接要经过4次握手也就是我们常说的四次挥手。当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个 FIN，它必须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。当客户端关闭连接时将会发送一个FIN，用来关闭从客户到服务器的数据传送当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加 1,同时TCP服务器还向应用程序传送一个文件结束符,接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN，客户必须发回一个确认，并将确认序号设置为收到序号加1(见图TCP2-2)
<img src="http://upload-images.jianshu.io/upload_images/10057179-0f33d9bdb825d90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP2-2.png"></p><ol start="3"><li>TCP的超时与重传</li></ol><p>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。</p><p>对每个连接，TCP管理4个不同的定时器：(1)重传定时器使用于当希望收到另一端的确认。(2)persist定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。(3)keeplive定时器可检测到一个空闲连接的另一端何时崩溃或重启。(4)2MSL定时器测量一个连接处于TIME_WAIT状态的时间。</p><h3 id="三、互联网的地址及域名"><a href="#三、互联网的地址及域名" aria-hidden="true" class="header-anchor">#</a> 三、互联网的地址及域名</h3><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32 bit。Internet地址并不采用平面形式的地址空间，如1、2、3等。IP地址具有一定的结构，五类不同的互联网地址格式如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-d85f69c74f692522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5类互联网地址.png"></p><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p><h3 id="四、http超文本传输协议"><a href="#四、http超文本传输协议" aria-hidden="true" class="header-anchor">#</a> 四、HTTP超文本传输协议</h3><p>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议，是一种无状态的协议，使用URI(统一资源标识符)定位互联网上的资源。在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><h4 id="http-1-1中的方法"><a href="#http-1-1中的方法" aria-hidden="true" class="header-anchor">#</a> HTTP/1.1中的方法</h4><ol><li>GET方法：获取资源</li></ol><p>来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。</p><ol start="2"><li>POST方法：传输实体主体</li></ol><p>用来传输实体的主体，虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p><ol start="3"><li>PUT方法：传输文件</li></ol><p>用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。存在安全性问题，因此一般的Web网站不使用该方法。</p><ol start="4"><li>HEAD方法：获得报文首部</li></ol><p>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p><ol start="5"><li>DELETE方法：删除文件</li></ol><p>用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。同样存在安全性问题，因此一般的Web网站不使用该方法。</p><ol start="6"><li>OPTIONS方法：询问支持的方法</li></ol><p>用来查询针对请求 URI 指定的资源支持。</p><ol start="7"><li>TRACE方法:追踪路径</li></ol><p>让Web服务器端将之前的请求通信环回给客户端。</p><ol start="8"><li>CONNECT方法：要求用隧道协议连接代理</li></ol><p>要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><hr><h4 id="cookie"><a href="#cookie" aria-hidden="true" class="header-anchor">#</a> Cookie</h4><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态，保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。它会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><h4 id="http状态码"><a href="#http状态码" aria-hidden="true" class="header-anchor">#</a> HTTP状态码</h4><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><table><thead><tr><th>状态码</th><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="http首部字段"><a href="#http首部字段" aria-hidden="true" class="header-anchor">#</a> HTTP首部字段</h4><blockquote><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p></blockquote><p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔。HTTP首部字段根据实际用途被分为以下 4 种类型:</p><ol><li>通用首部字段（General Header Fields）</li></ol><p>请求报文和响应报文两方都会使用的首部。</p><ol start="2"><li>请求首部字段（Request Header Fields）</li></ol><p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p><ol start="3"><li>响应首部字段（Response Header Fields）</li></ol><p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p><ol start="4"><li>实体首部字段（Entity Header Fields）</li></ol><p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p><hr><p>HTTP通用首部字段</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-2d55b84e40c9509b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP通用首部字段.png"></p><hr><p>HTTP请求首部字段</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-1fee69849d94c4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP请求首部字段.png"></p><hr><p>HTTP响应首部字段</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-1ec32716a667193c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP响应首部字段.png"></p><hr><p>HTTP实体首部字段</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-2f279530690e0362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP实体首部字段.png"></p><h4 id="http报文结构"><a href="#http报文结构" aria-hidden="true" class="header-anchor">#</a> HTTP报文结构</h4><p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文本身是由多行数据构成的字符串文本，大致可分为报文首部和报文主体两块。</p><p><img src="http://upload-images.jianshu.io/upload_images/10057179-3f9780d49a42b939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP报文结构.png"></p></div></div></div><div class="v-card__actions"><div class="flex xs12"><a href="/blog/Security"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">Security
            </span></span></a></div></div></article></div><div class="flex text-xs-left xs6"><a href="/posts/text-test.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text"><i class="fa mr-1 fa-chevron-left"></i>Prev
                </div><div class="title mt-1 primary--text hidden-xs-only title-font">程序猿生存指南</div></div></a></div><div class="flex text-xs-right xs6"><a href="/posts/webpack-Introduction.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text">Next
                    <i class="fa ml-1 fa-chevron-right"></i></div><div class="title mt-1 primary--text hidden-xs-only title-font">30分钟快速了解webpack</div></div></a></div></div></div></div></main><button type="button" class="v-btn v-btn--bottom v-btn--floating v-btn--fixed v-btn--right theme--light accent" style="display:none;background:#3a8ee6 !important;"><div class="v-btn__content"><i class="fa fa-lg fa-chevron-up"></i></div></button></div></div></div>
    <script src="/assets/js/app.7e3bbdcf.js" defer></script><script src="/assets/js/19.a350b227.js" defer></script>
  </body>
</html>
